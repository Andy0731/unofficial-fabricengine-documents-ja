.. _rtr2_extension:

RTR2 Extension
====================================================================================

.. image:: /images/FE_logo_345_60.*
   :width: 345px
   :height: 60px

| |FABRIC_PRODUCT_NAME| version |FABRIC_VERSION|
| |FABRIC_COPYRIGHT|

The ``RTR`` extension provides multiple components that can be assembled
for building a customized rendering pipeline. The RTR's goal is to provide
a good balance between performance and flexibility.

\note Various RTR samples are located in the ``/Samples/RTR2`` and can be run with the ``rtr2Test`` launcher, for example ``rtr2Test /Samples/RTR2/MovingHierarchy.kl --unguarded``.

Base interfaces and components
------------------------------

The RTR defines multiple types of base components and interfaces, such as:

- The :kl-ref:`RTRScheduler`, which allows to dynamically queue or schedule RTR processing 
  tasks (:kl-ref:`RTRTask`) or drawing tasks (:kl-ref:`RTRDrawTask`):
  
  - A :kl-ref:`RTRTask` is doing data preparation work, such as updating data
    associated to scene elements, or setting material parameters for
    draw instances. These tasks might be evaluated in parallel 
    and don't require a valid draw context.

  - A :kl-ref:`RTRDrawTask` is doing draw calls with as low overhead as possible
    since these are executed on the draw thread

- The :kl-ref:`RTRContext`, which provides the relevant contextual information
  for the tasks, such as the scene, the animation time and the camera

- The :kl-ref:`RTRInstance`, which represents a scene object such as a :kl-ref:`Geometry` instance.
  These are associated to a :kl-ref:`RTRMaterial`, and children :kl-ref:`RTRDrawInstance` can
  complete the :kl-ref:`RTRInstance` with material parameters that depend on the context
  (eg: the `modelViewMatrix`, which depends on the :kl-ref:`RTRDrawSurface` and :kl-ref:`RTRCamera`)

- A :kl-ref:`RTRMaterialLibrary`, which allows to share materials associated to
  shader files. The materials can either be:
  
  - a simple :kl-ref:`RTRMaterial`, such as the :kl-ref:`RTROGLProgram`, which defines a static
    parameter set and default values for the parameters (default values
    are defined as metadata in the shaders' code)

  - a generic material (:kl-ref:`RTRBaseGenericMaterial`), which provide "templated"
    material programs which will be specialized depending on generic parameters
    such as custom light or surface types (generic parameters are defined
    as metadata in the shaders' code)

Higher-level interfaces and components
--------------------------------------

Then, the RTR defines higher-level or more specialized components, such as:

- The :kl-ref:`RTRSWGeometryInstance`, which binds data from a scene geometry (:kl-ref:`SWElementReference`) to material
  parameters. These can be generated by a :kl-ref:`RTRSWGroupToInstanceTask` that maps scene
  geometry transformed instances to :kl-ref:`RTRSWGeometryInstance` objects.

- The :kl-ref:`GLStandardRTR`, a simple GL forward renderer that assigns lights to :kl-ref:`RTRDrawInstance` objects

- The :kl-ref:`RTROGLAmbientLight` and :kl-ref:`RTROGLDirectionalLight`, which are examples of generic 
  program sources (:kl-ref:`RTRGenericMaterialSource`) that can specialize the lighting of a generic OpenGL 
  material (:kl-ref:`RTROGLGenericProgram`)

.. _rtr_related_extensions:

Related extensions
-----------------

The following extensions work in conjunction with the RTR extension at various levels:

- The Adaptors extension allows to define target-specific :kl-ref:`ObjectAdaptor`
  that can manage and cache the conversion from source objects (such as
  a :kl-ref:`PolygonMesh`) to a specific target (such as OpenGL RTR). These adaptors
  can enable custom object types to be provided to the RTR with RTR specific
  types and interfaces.

- The SceneInterfaces extension defines generic interfaces and objects
  that abstract specific scene implementations such as the :kl-ref:`SceneGraph`.
  In particular, it defines:
  
  - The :kl-ref:`SWElementReference`, which allow to access associated values and track their changes by providing a version
  
  - :kl-ref:`SWDynamicGroup` objects, which provide groups of :kl-ref:`SWElementReference`. These can
    feed the RTR and allow efficient incremental updates under scene changes.

  - Adaptors associated to :kl-ref:`SWElementReference` source objects, which allows to 
    share RTR conversion data (such as GL buffers) by attaching these to the 
    shared source objects (such as a :kl-ref:`PolygonMesh`).

- The :kl-ref:`SceneGraph` extension provides an implementation of the generic SceneInterfaces interfaces,
  which allows the RTR to efficiently filter and process the SceneGraph content 
  without depending on its implementation details.

- The SceneGraphWrappers define higher-level scene graph objects, such as
  the :kl-ref:`SGInstance` and the :kl-ref:`SGGeometry`. These implement generic interfaces
  such as :kl-ref:`SWTransformed` which allow for a closer interaction with the RTR.

- The :kl-ref:`GeometryToRTR` extension defines some :kl-ref:`Geometry` specific RTR adaptors,
  such as the :kl-ref:`PolygonMeshToRTR` or the :kl-ref:`Vec3AttributeToRTR` adaptors.

- The SceneGraphToRTR extension defines adaptors for some SceneGraphWrapper
  objects to the RTR, such as :kl-ref:`SGDirectionalLightToRTR`. It defines, too,
  higher-level wrappings of the :kl-ref:`SceneGraph` for configuring it as an RTR
  input, such as :kl-ref:`SceneGraphToRTR`.

- The FabricOGL and OSOGL extensions define low-level wrapping of
  native OpenGL and OS-specific OpenGL extensions.

- The OGLWrappers extension defines higher-level wrapping of OpenGL
  object, such as buffers, framebuffer objects. It provides, too, functionality
  that is more closely related to RTR requirements, such as:
  
  - a `.glsl` preprocessor that can extract parameter meta-data and
    provide support for ``#include`` directives
  
  - versioning of GL wrapped objects, and ability to prepare some data
    without a GL draw context

  - chaining of :kl-ref:`OGLProgramParamValues`: parameter value sets that can 
    "inherit" from parent ones

Performance
-----------------

Being a realtime renderer, the RTR tries to deliver good performance while
being flexible, which can be challenging. The following practices are
followed by the RTR and related extensions to allow for a better performance:

- Minimize memory allocations and fragmentation: recycle existing allocated data or array 
  items instead of recreating them, regroup structures in contiguous arrays and avoid KL 
  dictionaries in performance sensitive situations (high fragmentation)

- Batch-process elements as much as possible, and regroup the working data sets in
  contiguous memory (arrays)

- Separate drawing from processing tasks, such that the RTR can eventually process
  the next frame while rendering, and so that processing tasks can be evaluated 
  by multiple threads

- Use versioning (Versioned interface) and caches at every step to allow for incremental 
  updates, so that a small scene change implies a small rendering data change. This complexifies 
  the implementation of the objects but is essential for having a good performance.

- Minimize thread locking: use spin locks (SimpleLock, LockedInitialize) for situations
  where locking is exceptional or occurs for a short period of time
  
- Avoid interface queries (converting from a type or interface to another type of interface)
  and avoid setting Object variables (use Ref<Object> when possible to avoid atomic reference count changes)

- Use `inline` for performance-sensitive small functions, split smaller portions that treat the frequent cases.

Table of Contents
-----------------

.. toctree::
  :maxdepth: 2
  
  files
  interfaces
  types
  functions
  constants

Indices and Tables
------------------

* :ref:`genindex`
* :ref:`search`
