#
msgid ""
msgstr ""
"Project-Id-Version: Fabric Engine 2.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-10-06 18:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\source\DebuggingGuide\introduction.rst:2
msgid "Introduction"
msgstr ""

#: ..\..\source\DebuggingGuide\introduction.rst:4
msgid ""
"|FABRIC_PRODUCT_NAME| provides functionality to aid in debugging "
"applications written using |FABRIC_PRODUCT_NAME| and KL. The Fabric Engine "
"debugger (called zBug and pronounced zee-bug) is based on `LLDB "
"<http://lldb.llvm.org/>`_ and as such aims to provide all of the "
"functionality found in exiting debugging software such as the Visual Studio "
"debugger or gdb while adding support for debugging KL code. With zBug a user"
" should be able to debug the full spectrum of code involved in a KL "
"application, including debugging C/C++ extensions. Because of the support "
"provided by LLDB zBug can also be used to debug pure C or C++ applications "
"or extensions using the same UI."
msgstr ""

#: ..\..\source\DebuggingGuide\introduction.rst:7
msgid "How Debugging Works"
msgstr ""

#: ..\..\source\DebuggingGuide\introduction.rst:9
msgid ""
"In broad strokes debugging a KL application is no different than debugging a"
" compiled C or C++ application. In both cases the compiled code will have "
"some information included in it to pass information to the debugger about "
"file names, line numbers, variable names, types, and other information. The "
"most common open format for this debug info is Dwarf, this is the format "
"used by most open compilers (with Microsoft's Visual Studio compiler being "
"the big exception) and this is the debug info format used by KL as well."
msgstr ""

#: ..\..\source\DebuggingGuide\introduction.rst:11
msgid ""
"When getting ready to debug a typical C++ application, a developer will "
"usually tell the compiler to include this debug info in the resulting "
"output. Debug info isn't included by default in all compiled code because it"
" takes additional time to produce and requires additional memory when "
"running the application."
msgstr ""

#: ..\..\source\DebuggingGuide\introduction.rst:13
msgid ""
"A developer will also normally tell the compiler to avoid running "
"optimization passes on the resulting code. Optimizing compiled code can "
"result in much faster execution times, however as the optimizer may change "
"the code significantly in order to achieve this it can make it harder to "
"debug as line numbers may change and variables that the developer wrote into"
" the code may be optimized away and replaced."
msgstr ""

#: ..\..\source\DebuggingGuide\introduction.rst:15
msgid ""
"Both of these ideas also hold true when debugging KL code. While a developer"
" can independently choose whether or not to run optimization on their KL "
"code and also whether or not to include debug info, in the general case for "
"debugging you will want to include debug info and disable optimizations. "
"Once your code has been written, debugged, and determined to work correctly "
"though you will usually want to disable debug info output to save on memory "
"and enable optimizations to allow the KL compiler to change your code as "
"necessary in order to make it as fast as possible."
msgstr ""
