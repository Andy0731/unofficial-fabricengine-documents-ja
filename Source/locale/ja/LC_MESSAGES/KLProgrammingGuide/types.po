#
msgid ""
msgstr ""
"Project-Id-Version: Fabric Engine 2.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-10-06 18:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\source\KLProgrammingGuide\types.rst:4
msgid "The KL Type System"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:6
msgid ""
"Unlike most languages, KL has a dynamic type system that is inherited from "
"the Fabric environment.  In most cases, compound types are registered from "
"the Fabric environment running in a dynamic language (eg. JavaScript or "
"Python); those types are then automatically made available to KL programs "
"running in that environment.  This does not, however, affect the semantics "
"of the language; the KL type system can still be explained purely from the "
"point of view of the language itself."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:8
msgid ""
"Like most programming languages, KL has support for both a fixed set of base"
" types from which other types are derived as well as different kinds of "
"derived types."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:14
msgid "Base Types"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:16
msgid "The base types in KL are the following:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:19
msgid ":code:`Boolean`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:19
msgid "can be either :code:`true` or :code:`false`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:22
#: ..\..\source\KLProgrammingGuide\types.rst:143
msgid "``UInt8``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:22
#: ..\..\source\KLProgrammingGuide\types.rst:143
msgid "an 8-bit unsigned integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:25
#: ..\..\source\KLProgrammingGuide\types.rst:146
msgid "``Byte``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:25
#: ..\..\source\KLProgrammingGuide\types.rst:146
msgid "an alias for ``UInt8``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:28
#: ..\..\source\KLProgrammingGuide\types.rst:149
msgid "``SInt8``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:28
#: ..\..\source\KLProgrammingGuide\types.rst:149
msgid "an 8-bit signed integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:31
#: ..\..\source\KLProgrammingGuide\types.rst:152
msgid "``UInt16``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:31
#: ..\..\source\KLProgrammingGuide\types.rst:152
msgid "a 16-bit unsigned integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:34
#: ..\..\source\KLProgrammingGuide\types.rst:155
msgid "``SInt16``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:34
#: ..\..\source\KLProgrammingGuide\types.rst:155
msgid "a 16-bit signed integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:37
#: ..\..\source\KLProgrammingGuide\types.rst:158
msgid "``UInt32``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:37
#: ..\..\source\KLProgrammingGuide\types.rst:158
msgid "a 32-bit unsigned integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:40
#: ..\..\source\KLProgrammingGuide\types.rst:173
msgid "``Count``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:40
msgid "an alias for ``UInt32``; used to represent cardinal numbers"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:43
#: ..\..\source\KLProgrammingGuide\types.rst:176
msgid "``Index``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:43
msgid "an alias for ``UInt32``; used to represent ordinal numbers"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:46
#: ..\..\source\KLProgrammingGuide\types.rst:182
msgid "``Size``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:46
msgid "an alias for ``UInt32``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:49
#: ..\..\source\KLProgrammingGuide\types.rst:161
msgid "``SInt32``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:49
#: ..\..\source\KLProgrammingGuide\types.rst:161
msgid "a 32-bit signed integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:52
#: ..\..\source\KLProgrammingGuide\types.rst:164
msgid "``Integer``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:52
#: ..\..\source\KLProgrammingGuide\types.rst:164
msgid "an alias for ``SInt32``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:55
#: ..\..\source\KLProgrammingGuide\types.rst:167
msgid "``UInt64``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:55
#: ..\..\source\KLProgrammingGuide\types.rst:167
msgid "a 64-bit unsigned integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:58
#: ..\..\source\KLProgrammingGuide\types.rst:179
msgid "``DataSize``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:58
msgid "an alias for ``UInt64``; used to represent sizes of blocks of memory"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:61
#: ..\..\source\KLProgrammingGuide\types.rst:170
msgid "``SInt64``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:61
#: ..\..\source\KLProgrammingGuide\types.rst:170
msgid "a 64-bit signed integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:64
#: ..\..\source\KLProgrammingGuide\types.rst:352
msgid "``Float32``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:64
msgid "a 32-bit IEEE floating point"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:67
#: ..\..\source\KLProgrammingGuide\types.rst:358
msgid "``Scalar``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:67
#: ..\..\source\KLProgrammingGuide\types.rst:358
msgid "an alias for ``Float32``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:70
#: ..\..\source\KLProgrammingGuide\types.rst:355
msgid "``Float64``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:70
msgid "a 64-bit IEEE floating point"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:73
msgid "``String``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:73
msgid "a sequence of zero or more characters"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:80
msgid "The :code:`Boolean` Type"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:82
msgid ""
"The value of an expression of :code:`Boolean` type is either logical true or"
" logical false.  The type has the following properties:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:84
msgid ""
"The constants :code:`true` and :code:`false` are :code:`Boolean` values with"
" logical values true and false, respectively."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:86
msgid "All other base types cast to Boolean as follows:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:88
msgid ""
"All values of integer type (eg. ``UInt32``, ``Byte``) cast to true if and "
"only if the value is non-zero"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:90
msgid ""
"All values of floating-point type (ie. ``Float32`` and ``Float64``) cast "
"true if and only if the value is not equal to ``0.0`` or ``-0.0``"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:92
msgid ""
"``String`` values cast to true if and only if their length is greater than "
"zero"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:94
msgid "Arrays and dictionaries cast to true if and only if they are non-empty"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:96
msgid ""
"By default, structures do not cast to :code:`Boolean`, but you can implement"
" the cast if desired by creating a :code:`Boolean` constructor that takes "
"the structure as a parameter; see :ref:`KLPG.constructor`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:98
msgid "For operators:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:100
msgid ""
"None of the arithmetic operators (binary ``+``, ``-``, ``*``, ``/``, ``%`` "
"as well as unary ``-`` and ``+``) are valid for :code:`Boolean` values"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:101
msgid ""
"Only the ``==`` and ``!=`` comparison operators are valid for "
":code:`Boolean` values"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:102
msgid ""
"All of the bitwise binary operators (``|``, ``&amp;``, ``^`` and ``~``) are "
"valid for :code:`Boolean` values and treat the value as if it were a single "
"bit"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:104
msgid "The following example shows the use of the :code:`Boolean` type::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:114
#: ..\..\source\KLProgrammingGuide\types.rst:201
#: ..\..\source\KLProgrammingGuide\types.rst:377
#: ..\..\source\KLProgrammingGuide\types.rst:434
#: ..\..\source\KLProgrammingGuide\types.rst:501
msgid "Output::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:138
msgid "Integer Types"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:140
msgid ""
"The ``UInt8``, ``SInt8``, ``UInt16``, ``SInt16``, ``UInt32``, ``SInt32``, "
"``UInt64`` and ``SInt64`` types, as well as their aliases (``Byte``, "
"``Integer``, ``Size``, ``Count``, ``Index`` and ``DataSize``), are "
"collectively known as the :index:`integer types` and represent whole "
"integers.  These types differ only in their bit width and whether they are "
"signed or unsigned, as follows:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:173
msgid ""
"an alias for ``UInt32``.  ``Size`` is usually used to count the number of "
"elements in an array"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:176
msgid ""
"an alias for ``UInt32``.  ``Index`` is usually used to index into an array"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:179
msgid ""
"an alias for ``UInt64``.  ``DataSize`` is used to represent the size of a "
"block of memory and is the return type for the ``dataSize`` method of types."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:182
msgid "an alias for ``UInt32``."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:184
msgid "Integer types behave as follows:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:186
msgid ""
"All of the :ref:`arithmetic <arithmetic-ops>`, :ref:`logical <logical-ops>` "
"and :ref:`bitwise <bitwise-ops>` operators work as expected for all integer "
"types."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:188
msgid ""
"Integer constants are typed using the suffixes ``s32`` for ``SInt32``, "
"``u64`` for ``UInt64``, and so on; if a suffix is omitted, the type is "
"``SInt32``.  For more details, see :ref:`integer-constants`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:190
msgid "The following shows the use of integer types::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:212
msgid "Integer Atomic Methods"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:214
msgid ""
"The integer types have a set of built-in :ref:`methods` that perform atomic "
"operations on a value of the type.  Atomic operations are used to implement "
"lock-free algorithms; for more information on atomic operations, see "
"http://en.wikipedia.org/wiki/Linearizability."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:229
msgid "Atomically add a value to the integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:231
#: ..\..\source\KLProgrammingGuide\types.rst:260
msgid "The value to add"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:232
#: ..\..\source\KLProgrammingGuide\types.rst:246
#: ..\..\source\KLProgrammingGuide\types.rst:261
#: ..\..\source\KLProgrammingGuide\types.rst:275
#: ..\..\source\KLProgrammingGuide\types.rst:290
#: ..\..\source\KLProgrammingGuide\types.rst:305
#: ..\..\source\KLProgrammingGuide\types.rst:320
#: ..\..\source\KLProgrammingGuide\types.rst:338
msgid "the old value of the integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:244
msgid "Atomically increments the integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:258
msgid "Atomically subtracts a value from the integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:273
msgid "Atomically decrements the integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:287
msgid "Atomically perform a bitwise or on the integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:289
msgid "The value to or with the integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:302
msgid "Atomically perform a bitwise and on the integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:304
msgid "The value to and with the integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:317
msgid "Atomically perform a bitwise xor on the integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:319
msgid "The value to xor with the integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:332
msgid ""
"Atomically perform a compare-and-swap operation: if the integer's value is "
"``oldVal``, change it to ``newVal``.  Returns ``oldVal`` if and only if the "
"value was changed."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:336
msgid "The value to compare with the integer"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:337
msgid "The value to set the integer to if the comparison succeeds"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:347
msgid "Floating-Point Types"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:349
msgid ""
"The ``Float32`` and ``Float64`` types (as well as ``Scalar``, an alias for "
"``Float32``) are collectively known as :dfn:`floating-point types` and "
"represent :abbr:`IEEE` floating-point numbers.  These types differ only in "
"their bit width, as follows:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:352
msgid "a 32-bit :abbr:`IEEE` floating-point number"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:355
msgid "a 64-bit :abbr:`IEEE` floating-point number"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:360
msgid "Floating-point types behave as follows:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:362
msgid ""
"Floating-point constants have the same syntax as in JavaScript and C, and "
"are of type ``Float64``.  For more details, see :ref:`floating-point-"
"constants`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:364
msgid ""
"All of the :ref:`arithmetic <arithmetic-ops>` and :ref:`logical <logical-"
"ops>` operators are valid for floating-point values.  None of the bitwise "
"operators are valid for floating-point values."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:366
msgid "The following example shows the use of floating-point types::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:388
msgid "The ``String`` Type"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:390
msgid ""
"The ``String`` type represents a text string, ie. a sequence of zero or more"
" characters.  A value of type ``String`` is referred to as a :index:`string "
"value`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:392
msgid ""
"The semantics of the ``String`` type in KL are important to understand.  "
"Strings have the following key properties:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:394
msgid "A string is a sequence of zero or more characters."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:396
msgid ""
"The length of a string is value of type ``Size``, and the maximum length of "
"a string is :math:`2^31-1`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:398
msgid ""
"String constants can be specified inline in KL source files using single- or"
" double-quotation marks, just as in Python and JavaScript.  For more details"
" and examples of string constants, see :ref:`string-constants`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:400
msgid "Strings support the following operations and properties:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:402
msgid ""
"They have a ``.length`` property which returns the number of characters in "
"the string"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:404
msgid ""
"The ``+=`` assignment operator is used to append another string to a given "
"string"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:406
msgid ""
"A new string can be created by concatenating two other strings using the "
"``+`` binary operation"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:408
msgid ""
"Strings can be compared using the usual ``==``, ``!=``, ``<``, ``<=``, ``>``"
" and ``>=`` logical operators.  Additionally, they support the "
":samp:`{string}.compare({otherString})` method that returns -1, 0 or 1 "
"depending on whether :samp:`{string}` is less than, equal to or greater than"
" :samp:`{otherString}`, respectively."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:410
msgid ""
"Strings can be indexed into using the :samp:`{string}[{index}]`.  The result"
" is a string containing the single character at the given index.  "
":samp:`{index}` must be in the range :math:`[0...2^31-1]`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:412
msgid ""
"A 32-bit hash value for the string can be obtained with the "
":samp:`{string}.hash()` method."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:414
msgid "Unlike C or C++, strings can contain the null character (ASCII 0)."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:416
msgid ""
"Strings have no notion of encoding; they are just sequences of bytes.  "
"String encodings are determined by the application space where the strings "
"are used.  Note that everything in Fabric itself uses the UTF-8 encoding, "
"but Fabric extensions may need to convert strings into other encodings."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:418
msgid ""
"All other types in KL can be converted to strings through a cast; this "
"conversion simply creates a string that is a human-readable version of the "
"value.  This conversion can be overridden for custom types by writing a "
"custom :samp:`function {Type}.appendDesc(io String string)` method; see :ref"
":`conversion-funcs`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:420
msgid "Example use of the ``String`` type::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:449
msgid "Derived Types"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:451
msgid ""
"In addition to the base types, KL supports three classes of derived types: "
"structures, arrays and dictionaries."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:460
msgid "Structures"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:462
msgid ""
"A :dfn:`structure` is a collection of typed values that are placed together "
"in memory."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:464
msgid ""
"Structures are usually defined outside of KL using Fabric's "
":index:`registered type system`, but they can also be declared in KL source "
"code itself using the ``struct`` keyword::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:472
msgid ""
"Note the use of the variable-size array as the last member; derived types "
"can nest arbitrarily."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:474
msgid ""
"All structure declarations in KL must be in the global scope; it is not "
"possible to declare a structure within a function scope."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:476
msgid "More details about structures:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:478
msgid ""
"Access to structure members is through the ``.`` (dot) operator, as in "
"JavaScript."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:480
msgid ""
"Currently, the structure members are using C-like alignment (see :ref"
":`structure-alignment`)."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:482
msgid ""
"It is possible to overload operators and add :dfn:`methods` to structures; "
"see :ref:`methods`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:484
msgid ""
"It is possible to control access to members and methods of structures using "
"the ``public``, ``private``, ``protected`` and ``permits`` keywords; see "
":ref:`KLPG.types.member-access`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:486
msgid "Example use of structures::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:512
msgid "Structure Member Alignment"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:514
msgid ""
"The alignment of members of structures is identical to that of the C "
"programming language.  Therefore, EDK code that interfaces with the "
"|FABRIC_PRODUCT_NAME| does not need to use any special alignment "
"specification to match the KL structure alignment."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:519
msgid ""
"For reference, the rules of KL structure alignment (the same as the C "
"default) are:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:522
msgid "Every type has a size and an alignment"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:524
msgid "The alignment of base types is the same as their size"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:526
msgid ""
"The alignment of structures (as a whole) is the largest alignment of any of "
"its member types"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:529
msgid ""
"The byte position of a member within a structure is chosen by rounding up "
"the next available offset in the structure to the alignment of the member "
"type"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:539
msgid "Structure Inheritance"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:543
msgid ""
"A structure can inherit (or `derive`) from a single base structure. The "
"specialized structure then inherits from all members and methods of the base"
" structure."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:545
msgid ""
"The :samp:`struct {SpecializedType} : {BaseType}` syntax is used to declare "
"the inheritance relationship. A specialized structure can be `cast` to its "
"base structure type at no cost. The :samp:`.parent` accessor allows to "
"perform that cast explicitly."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:569
msgid ""
"When cast to its base type, a structure looses all its specialized behavior,"
" which is different from :ref:`objects <KPLG.object.inheritance>`:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:597
msgid "Objects"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:599
msgid "Can no longer do \"empty construction\" of variables of object type"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:602
msgid ""
"An :dfn:`object` is similar to a :ref:`structure <KLPG.types.structures>` in"
" that it is a collection of typed values placed together in memory, except "
"that objects are copy-by-reference rather than copy-by-value; objects must "
"be :dfn:`constructed` and are internally reference-counted.  Additionally, "
"objects can support :ref:`interfaces <KLPG.types.interfaces>`, which are a "
"collection of methods that the object is guaranteed to support."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:604
msgid ""
"Objects are used in much the same way as structures, with the major "
"difference being that they are copy-by-reference and must be constructed.  "
"KL internally keeps track of the number of references to each object and "
"when the last reference to an object is dropped the memory holding the "
"object is freed.  Objects drop their references when they go out of scope, "
"or when they have :code:`null` assigned to them."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:606
msgid ""
"Objects are defined using the :code:`object` keyword in KL.  The syntax is "
"very similar to the definition of :ref:`structures <KLPG.types.structures>`:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:616
msgid ""
"Optionally, the object can derive from one base object, and implement one or"
" more :ref:`interfaces <KLPG.types.interfaces>`.  There are indicated after "
"the name of the object:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:626
msgid ""
"Variables whose type is that of a given object are declared with the name of"
" the object."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:634
msgid ""
"The value :code:`null` refers to a non-existent object.  You can report an "
"object that is :code:`null`, but trying to reference its members or call "
"methods on it will result in a runtime error."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:636
msgid ""
"Any variable of Object type can be set to :code:`null`.  Doing almost "
"anything with a :code:`null` object will result in a runtime error.  To "
"create a valid object it must be constructed.  There are two syntaxes for "
"constructing objects:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:648
msgid ""
"Objects cannot be \"empty constructed\"; you must explicitly construct "
"objects or explicitly set their values to :code:`null`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:650
msgid ""
":ref:`Constructors <KLPG.constructor>` and :ref:`destructors "
"<KLPG.destructor>` can be specified for objects just as they are for "
"structures:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:672
msgid ""
"Constructing a specific object from another object of the same type makes "
"the new object a reference to the old object.  In this case, a new object is"
" not created; if the object is modified through one of the references to it "
"then the other see the modifications as well."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:681
msgid ""
"Users cannot define a custom copy constructor for objects for this reason, "
"the copy constructor always only adds a reference to the existing object. If"
" a user wants to instantiate a new object then the ``clone()`` method (see "
":ref:`KLPG.types.objects.clone`) or a custom method should be used."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:720
msgid ""
"Arbitrary methods can be defined on objects just as they are on structures."
"  These methods are then called using the same "
":samp:`{object}.{methodName}({arg},{arg},...)` syntax as for structures.  "
"Calling a method on a :code:`null` object results in a runtime exception."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:731
msgid ""
"Members of objects are accessed in the same way as members of structures by "
"using the :samp:`{object}.{memberName}` syntax.  Using the :code:`.` "
"operation on a :code:`null` object will throw a runtime exception."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:733
msgid "Additional properties of objects:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:735
msgid ""
"If an value of object type is converted to a :code:`Boolean` then its value "
"is :code:`true` if and only if the object is not :code:`null`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:737
msgid ""
"The :ref:`equality operators <equality-ops>` :samp:`{obj1} == {obj2}` and "
":samp:`{obj1} != {obj2}` are only valid for objects when overloaded or when "
"comparing with :code:`null`.  The :ref:`identity operators <identity-ops>` "
":samp:`{obj1} === {obj2}` and :samp:`{obj1} !== {obj2}` are always valid for"
" objects and compare based on whether the objects are references to the same"
" object (ie. if changing one will change both)."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:739
msgid ""
"Values of object type support the method :samp:`<objectValue>.uid()` that "
"returns a unique UInt64 that can be used to identify the object.  The value "
"is the same as it would be if `.uid()` were called on the object casted to "
"any of the interfaces the object supports."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:741
msgid ""
"Assigning :code:`null` to an object drops the reference to whatever the "
"object was previously pointing to."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:743
msgid ""
"It is possible to control access to members and methods of objects using the"
" ``public``, ``private``, ``protected`` and ``permits`` keywords; see "
":ref:`KLPG.types.member-access`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:745
msgid ""
"A variable of whose type is an object cannot point to a structure.  Objects "
"and interfaces are fundamentally different types than structures; see the "
"section :ref:`KLPG.objects-versus-structures`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:747
msgid "The following code provides another example of using object:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:780
msgid "The Object ``clone()`` Method"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:784
msgid ""
"As with most other types in KL object types support a method ``clone()`` "
"that does a deep copy of the object.  Every object has a default ``clone()``"
" implementation.  It is possible to change the behavior of ``clone()`` for "
"an object by writing a custom method ``<ObjectType>.cloneMembersTo(io "
"<ObjectType> that)``.  This method is automatically called during the "
"process of cloning the object, as shown below:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:814
msgid "Object inheritance"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:818
msgid ""
"Like structures, an object can inherit (or `derive`) from a single base "
"object. The specialized object then inherits from all members and methods of"
" the base object. The :samp:`struct {SpecializedType} : {BaseType}` syntax "
"is used to declare the inheritance relationship."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:820
msgid ""
"When inheriting from a base object, the :samp:`{object}.{parent}` syntax "
"allows to perform an explicit cast to that base type. This can be useful for"
" accessing members or methods that have a different definition for the base "
"and the specialized object type."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:848
msgid "Interfaces"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:850
msgid "Can no longer do \"empty construction\" of variables of interface type"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:853
msgid "Added support for ``<typeExpr>.createNew()`` method"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:856
msgid ""
"An :dfn:`interface` is a set of methods that an object agrees to implement."
"  Objects implement the interface by declaring the interface name in the "
"object declaration as well as implementing each of the interface's methods."
"  The programmer can then use the interface as a first-class type that "
"refers to any type of object that implements the interface."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:858
msgid ""
"An interface is defined using the :code:`interface` keyword.  An interface "
"definition is similar to a structure or object definition, except that, "
"instead of members, methods are specified.  For example:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:868
msgid ""
"This example defines the interface :code:`MyInt` as providing three methods."
"  The parameter and return types all work the same as for normal structure "
"and object :ref:`methods <methods>`; however, the :code:`function` keyword "
"and the typename are omitted.  Notice that the :code:`!` and :code:`?` "
"modifiers for the methods also work, indicating explicitly whether the "
"methods may modify the object they are called on."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:870
msgid ""
"An interface only specifies a set of methods that objects implementing the "
"interface must support.  In order to use interfaces, you must define objects"
" that support them:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:892
msgid ""
"Notice that, in order to implement the interface, we both list the interface"
" after the object type name and the provide implementations for each of the "
"methods."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:896
msgid ""
"It is a compile-time error to fail to provide a definition for one or more "
"of the methods required by the interfaces an object implements!"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:898
msgid "It is possible for an object to implement multiple interfaces:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:928
msgid ""
"Notice that it's possible for an object to support multiple interfaces that "
"share methods.  In this case you only need to implement the method once and "
"that implementation will be shared by all interfaces that include this "
"method."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:930
msgid ""
"Once an interface has been defined, you can declare a variable that points "
"to an object that implements the interface and call its methods using the "
":samp:`{int}.{methodName}({arg}, {arg}, ...)` syntax:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:944
msgid ""
"Using the :samp:`{interface}.type()` method you can determine the type of "
"the object in interface refers to, and through an assignment or a cast you "
"can obtain a specific object.  This allows for a simple form of weak (or "
"runtime) typing in KL:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:955
msgid ""
"In the case that an expression is of type :code:`Type` then calling the "
"``<typeExpr>.createNew()`` method will create a new instance of the object "
"the interface is an instance of using its empty constructor.  The result is "
"of the :ref:`Object interface <KLPG.interfaces.object>` type:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:976
msgid ""
"Assigning or casting an interface to the wrong object will result in a "
"runtime exception.  You can also assign a value whose types is one interface"
" to a variable whose type is another interface; if the underlying object "
"supports the second interface, you will get a non-:code:`null` reference to "
"the second interface on the object, otherwise a runtime exception will "
"occur."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:978
msgid "Additional properties of interfaces:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:980
msgid ""
"The cast-to-:code:`Boolean` works exactly as for objects: it checks if the "
"interface referred to is :code:`null`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:982
msgid ""
"The comparison operators :samp:`{int1} == {int2}` and :samp:`{int1} != "
"{int2}`, as well as the identity operators :samp:`{int1} === {int2}` and "
":samp:`{int1} !== {int2}`, test whether two interfaces refer to the same (or"
" different) objects. to whatever object it previously referred to."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:984
msgid ""
"Values of interface type support the method :samp:`<interfaceValue>.uid()` "
"that returns a unique UInt64 that can be used to identify the object the "
"interface refers to.  The value is the same as it would be if `.uid()` were "
"called on the object the interface refers to."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:986
msgid ""
"It is possible to control access to methods of interfaces using the "
"``public``, ``private``, ``protected`` and ``permits`` keywords; see "
":ref:`KLPG.types.member-access`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:988
msgid ""
"A variable of whose type is an interface cannot point to a structure.  "
"Objects and interfaces are fundamentally different types than structures; "
"see the section :ref:`KLPG.objects-versus-structures`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:993
msgid "The :code:`Object` Interface"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:995
msgid ""
"There is a special, predefined interface called :code:`Object` that every "
"object in KL always supports.  This both provides backwards compatibility "
"with older versions of the KL language as well as providing a simple way of "
"passing a reference to an arbitrary object (much like a \"void pointer\" in "
"C).  The :code:`Object` interface does not provide any methods."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1010
msgid "Structure, Object and Interface Access Contols"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1014
msgid ""
"Access to members and methods of structures, objects and interfaces can be "
"controlled through the use of the ``public``, ``private`` and ``protected`` "
"keywords.  These keywords behave in a similar way to C++:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1016
msgid ""
"A member or method marked as ``public`` can be accessed by any part of the "
"source code.  This is the behavior when no access is specified."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1018
msgid ""
"A member or method marked as ``private`` can be only be accessed by methods "
"of the structure or object.  Trying to access the member elsewhere will "
"result in an error when the source code is compiled."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1020
msgid ""
"A member or method marked as ``protected`` can be only be accessed by "
"methods of the structure or object as well as structures or objects that "
"inherit from it.  Trying to access the member elsewhere will result in an "
"error when the source code is compiled."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1054
msgid ""
"It is possible to allow a structure or object to bypass this mechanism from "
"within its methods by using the ``permits`` keyword.  If a structure or "
"object is listed in the ``permits`` section of another structure or object, "
"it can access its private and protected members and methods:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1099
msgid "Interfaces and inheritance"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1103
msgid ""
"In addition to inherit from a :ref:`base object type "
"<KPLG.object.inheritance>`, specialized objects can implement additional "
"interfaces."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1112
msgid ""
"If a base object implements an interface, the specialized object can provide"
" its own implementation of the interface methods, which will `override` base"
" type's implementation. In this situation, special syntax is required to "
"call base class's implementation of the same interface method: see "
":ref:`KLPG.method.interface-inheritance`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1117
msgid "Forward Declaration of Objects and Interfaces"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1119
msgid "Forward declaration of objects and interfaces"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1122
msgid ""
"It is possible to declare the existence of an object or interface without "
"actually defining its members; this is useful when you have a set of co-"
"dependent objects or interfaces.  To forward-declare an object or interface,"
" simply omit the members, methods and/or implemented interfaces."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1175
msgid "Unowned Object and Interface References"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1177
msgid ""
"The runtime cost of tracking all of the references to objects and interfaces"
" can be high.  In certain situations it is desireable to avoid this "
"reference tracking for performance reasons when it is known that there will "
"always be at least one reference to the object in question.  Kl provides the"
" ability to do this using the :samp:`Ref<{ObjectType}>` and "
":samp:`Ref<{InterfaceType}>` syntax.  This also provides the ability to "
"create object and interface reference loops that do not leak memory."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1179
msgid ""
"Unowned references behave exactly the same as regular object and interface "
"references; the only difference is that they don't track references."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1181
msgid ""
"It is very easy to create subtle bugs and crashes when using unowned "
"references.  Use them at your own risk!  It is your responsibility to ensure"
" that unowned references refer to objects that are owned by something else."
"  You can leave an unowned reference refering to an object that has been "
"destroyed but if you try to do anything with it your program will probably "
"crash!"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1183
msgid "Example use of unowned references:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1203
msgid "The :code:`Type` Type"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1205
msgid ""
"There is a special type in KL called :code:`Type`.  It represents the type "
"of a value in KL.  Every value in KL supports a method "
":code:`{value}.type()` that can be used to obtain the type of the object, "
"which is a value of type :code:`Type`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1209
msgid ""
"The default value of a variable of type :code:`Type` is the special value "
":code:`None`.  This is also sometimes the return value of some methods "
"described below.  :code:`None` is not equal to :code:`{value}.type()` for "
"any :code:`{value}`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1211
msgid ""
"You can only do a few things with values of type :code:`Type`; they are "
"primarily used for runtime type inference with interfaces and objects."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1213
msgid ""
"You refer to a value of type :code:`Type` just by refering to the value of "
"the type; you can then use this for comparisons:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1227
msgid ""
"For :ref:`interfaces <KLPG.types.interfaces>` the :code:`{value}.type()` "
"method returns the type of the specific object that the generic object "
"refers to; this is how you do runtime type inference on objects.  See "
":ref:`KLPG.types.interfaces` for more information."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1229
msgid ""
"Values of type :code:`Type` support the method :code:`{value}.parentType()`."
"  In the case that the type of :code:`{value}` is a structure or object type"
" with an inherited parent, :code:`parentType()` returns the type of the "
"parent; otherwise, :code:`parentType()` returns :code:`None`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1248
msgid ""
"Values of type :code:`Type` support the method "
":code:`{value}.isA({interfaceType})`, which returns :code:`true` if and only"
" if :code:`{value}` supports the interface :code:`{interfaceType}`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1282
msgid ""
"You can obtain a description of the type by calling the method "
":code:`{typeValue}.jsonDesc()`.  You can use this to find out things like "
"the members of structures at runtime:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1306
msgid "Objects Versus Structures"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1308
msgid ""
"The decision to use a structure versus an object for a composite type is an "
"important design decision that affects program design as well as runtime "
"behavior and performance."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1310
msgid ""
"Structures are usually the best choice for small types that are performance-"
"critical.  If you have complex expressions that will create a lot of "
"temporary values of the given type, you probably want to be using a "
"structure and not an object.  One critical performance aspect is that "
"variables whose types are structures are allocated on the program stack; "
"this means that there is virtually no overhead to allocating and freeing the"
" memory associated with the structure.  Examples of types that should "
"usually be structures are mathematical types such as vectors and transforms."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1312
msgid ""
"Objects are usually the best choice for large types that are created and "
"destroyed less significantly less often than they are used.  Objects are "
"allocated on the heap, which is significantly slower than stack allocation."
"  Additionally, since you can have many different variables point to the "
"same object, objects are a good choice when you want lots of references to "
"the same data.  Hierarchies of data are usually represented with objects."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1321
msgid "Arrays"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1323
msgid ""
"An :dfn:`array` is a sequence of values of the same type (referred to as the"
" array's :dfn:`element type`) that are indexed by integers and placed "
"sequentially in memory.  KL supports three types of arrays: variable-size "
"arrays, fixed-length arrays, and external arrays.  The details of each array"
" type are discussed below."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1327
msgid ""
"Regardless of specific type, arrays in KL have several common behaviors:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1329
msgid ""
"Arrays are indexed using the ``[..]`` operator, exactly as in JavaScript and"
" C.  The indexing of arrays is 0-based, again just as in JavaScript and C::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1337
msgid ""
"The size of an array is of type ``Size`` and the indexing operator takes an "
"index of type ``Index`` (which is an alias for ``Size``)."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1339
msgid ""
"Array declarations can be nested, and can be co-nested with other array "
"types::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1345
msgid ""
"Arrays are :dfn:`passed by reference` into functions and operators, ie. they"
" are not copied.  This means that it takes just a long to pass an array with"
" one million elements to a function as it does to pass an array with one "
"element."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1347
msgid ""
"If running a Fabric client with bounds-checking enabled, indexing into "
"arrays using the indexing operator is bounds-checked; if the index runs off "
"the end of the array an exception is thrown."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1356
msgid "Variable-Size Arrays"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1358
msgid ""
"A :dfn:`variable-size array` is an array whose size can be changed at "
"runtime.  Variable-size arrays are declared by appending ``[]`` to the name "
"of the variable, parameter or structure member where they are declared, eg. "
"``String strings[]``."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1360
msgid ""
"Variable-size arrays have all the :ref:`properties of arrays <array-"
"properties>` as well as the following additional properties:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1362
msgid "The maximum size of a variable-size array is :math:`2^31-1`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1364
msgid ""
"Variable-size arrays are :dfn:`share-on-assign`, meaning that when you "
"assign one variable-size array to another it does not copy the elements but "
"rather copies a reference to the elements; any changes to one of the arrays "
"changes the other as well.  This is sometimes referred to as a shallow copy "
"(as opposed to a deep copy).  In order to obtain a deep copy of an array, "
"use the ``clone()`` method, described below."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1366
msgid "Variable-size arrays support the following methods and functions:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1368
msgid ""
"By default, a variable array is empty.  If you specify an integer value when"
" it is constructed, the variable array will initially have that many "
"elements."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1370
msgid ""
"The ``push(element)`` method appends an element to the end of the variable-"
"size array.  The size of the array is increased by one."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1372
msgid ""
"The ``pop()`` method removes the last element from the end of the array, and"
" returns that element.  The size of the array is reduced by one.  Calling "
"``pop()`` on an empty array results in an error."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1374
msgid ""
"The ``size()`` method returns the number of elements in the variable-size "
"array"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1376
msgid ""
"The ``resize(newSize)`` method resizes the array.  Any new elements at the "
"end are initialized with the default value for the underlying type."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1378
msgid ""
"The ``reserve(count)`` method ensures that space is allocated for at least "
"``count`` elements.  If you know the final number of elements in advance, it"
" is much faster to call ``reserve(...)`` before calling ``push(...)`` many "
"times."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1380
msgid ""
"The ``clone()`` method makes a deep copy of the variable-size array.  The "
"resulting copy is initially not shared with any other variable-size array."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1382
msgid ""
"The ``swap(Size lhsIndex, Size rhsIndex)`` method swaps the values of the "
"array at the two given indices."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1384
msgid ""
"The :samp:`swap({Type} lhs[], {Type} rhs[])` function swaps the contents of "
"the two variable-size arrays.  This swap is performed in constant time and "
"does not copy any data."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1407
msgid "Fixed-Size Arrays"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1409
msgid ""
"A :dfn:`fixed-size array` is an array whose size is fixed at runtime.  "
"Fixed-size arrays have much faster performance characteristics than "
"variable-size arrays, therefore should be used in place of variable-sized "
"arrays when the size of an array is known at compile time.  Fixed-size "
"arrays are declared by appending :samp:`[{size}]` to the name of the "
"variable, parameter or structure member where they are declared, eg. "
"``String strings[4]``."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1411
msgid ""
"Fixed-size arrays have all the :ref:`properties of arrays <array-"
"properties>` as well as the following additional properties:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1413
msgid "The maximum size of a fixed-size array is :math:`2^31-1`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1417
msgid ""
"Since fixed-size arrays are allocated on the stack (instead of the heap), "
"using very large fixed-size arrays may result in a stack overflow.  It is "
"recommended that fixed-size arrays only be used for arrays that are "
"reasonably small."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1419
msgid ""
"Fixed-size arrays are copied when they are assigned, ie. they are :dfn"
":`copy-by-value`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1443
msgid "External Arrays"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1445
msgid ""
"An :dfn:`external array` is an array whose size is fixed when it is created "
"and does not own the data is operates on.  External arrays are primarily "
"used for operator parameters bound to sliced data inside a "
"|FABRIC_PRODUCT_NAME| dependency graph as well as arrays bound to external "
"data within |FABRIC_PRODUCT_NAME| extensions, but they can also be used on "
"their own within KL.  External arrays are declared by appending ``<>`` to "
"the name of the variable, parameter or structure member where they are "
"declared, eg. ``String strings<>``."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1447
msgid ""
"External arrays have all the :ref:`properties of arrays <array-properties>` "
"as well as the following additional properties:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1449
msgid ""
"An external array can be constructed from an existing variable array.  This "
"simply points the external array to the data within the variable array at "
"the time the variable array is constructed.  Note however that there are "
"lots of ways that this usage can break, such as through resizing the "
"variable array.  This usage is primarily meant for testing::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1456
msgid ""
"External arrays support an empty constructor (which constructs an empty "
"external array)::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1461
msgid ""
"External arrays support a copy constructor and an assignment operator, both "
"of which simply make one external array refer to the same data as the "
"other::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1472
msgid ""
"External arrays support a ``size()`` method that returns the number of "
"elements in the external array."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1474
msgid ""
"External arrays can be initialized given a ``data`` pointer as well as a "
"``size``. This allows you to map arbitrary memory as an array. This is very "
"useful especially when passing data from C++ into KL and back out. You can "
"also use this constructor to reinterpret any memory as an array::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1483
msgid ""
"As opposed to variable arrays, External arrays are not ref counted objects. "
"This makes them cheaper to pass around, but can't be used to manage the "
"lifetime of memory. (See next point)"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1485
msgid ""
"External arrays do not manage the lifetime of the data they operate on. A "
"variable array will free its memory when it is destroyed, but an external "
"array is simply a mapping to memory owned by something else. An external "
"array should never out-live the owner of the data, else it will map to "
"garbage data::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1501
msgid "The following is an example of using external arrays:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1524
msgid "Dictionaries"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1526
msgid ""
"KL supports key-value pair :dfn:`dictionaries`.  The type of the key of a "
"dictionary can be any of the KL base types (e.g. :code:`Boolean`, "
"``String``, or any integer or floating-point type) as well as custom types "
"for which a special :samp:`.hash` method has been defined (see "
":ref:`KLPG.dictionaries.custom-key-types`) and the type of the value can be "
"any type.  Dictionaries are declared by appending :samp:`[{KeyType}]` to the"
" variable, parameter or member name.  For example:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1534
msgid "Dictionaries in KL have the following properties:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1536
msgid ""
"Dictionaries are :dfn:`share-on-assign`, meaning that when you assign one "
"dictionary to another it does not copy the contents but rather copies a "
"reference to the contents; any changes to one of the dictionaries changes "
"the other as well.  This is sometimes referred to as a shallow copy (as "
"opposed to a deep copy).  In order to obtain a deep copy of a dictionary, "
"use the ``clone()`` method, described below."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1538
msgid ""
"Dictionaries can be nested, and can be co-nested with array types.  For "
"example:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1546
msgid "Dictionaries can contain at most :math:`2^32-1` key-value pairs."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1548
msgid ""
"Dictionaries support the :samp:`has({key})` method that returns a "
":code:`Boolean` value indicating whether there is a value in the dictionary "
"for the given key."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1550
msgid ""
"Dictionaries support the :samp:`get({key})` method that returns the value "
"associated with the given key.  If there is no value for the given key, an "
"exception is thrown."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1552
msgid ""
"Dictionaries support the :samp:`set({key}, {value})` method that sets the "
"value for the key, replacing the existing value if there is already a value "
"for the key."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1554
msgid ""
"Dictionaries support indexing using the :samp:`[{key}]` indexing operator.  "
"When used as the target of an assignment or as an io parameter to a function"
" (eg. :samp:`{dict}[{key}] = {value}`), it is equivalent to using the "
":samp:`set({key}, {value})` method.  When used as a read-only expression "
"(eg. :samp:`{value} = {dict}[{key}]`), it is equivalent to using the "
":samp:`get({key})` method."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1556
msgid ""
"Dictionaries support the :samp:`get({key}, {defaultValue})` method that "
"returns the value associated with the given key, if it exists, or "
":samp:`{defaultValue}`` if there is no value for the given key."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1558
msgid ""
"Dictionaries support the :samp:`delete({key})` method that deletes the value"
" for the given key.  If there is no value for the given key, nothing "
"happens."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1560
msgid ""
"Dictionaries support the ``clone()`` method which makes a deep copy of the "
"dictionary.  The resulting copy is initially not shared with any other "
"dictionaries."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1562
msgid ""
"Dictionaries support the ``clear()`` method which removes all keys and "
"values."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1564
msgid ""
"Dictionaries can be iterated over using JavaScript-like ``in`` iteration:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1573
msgid ""
"For improved performance, both the key and value can be made available "
"through ``in`` iteration:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1582
msgid ""
"In a dictionary iteration, the value can be assigned to if and only if the "
"dictionary can be assigned to.  The key, on the other hand, cannot be "
"assigned to."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1584
msgid ""
"Insertion order (not sort order!) is the iteration order for dictionaries, "
"just as for JavaScript objects:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1597
msgid "The following is an example use of dictionaries:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1622
msgid "Dictionaries Using Custom Key Types"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1624
msgid ""
"You can use a custom :samp:`struct` as a key type for a dictionary by "
"implementing a :samp:`.hash` method for the type as well as a :samp:`==` "
"operator:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1658
msgid "Map-Reduce Types"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1660
msgid ""
"There are two additional derived types used exclusively for work within "
"Fabric's map-reduce framework, namely:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1662
msgid ":samp:`ValueProducer<{Type}>`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1663
msgid ":samp:`ArrayProducer<{Type}>`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1665
msgid "For more information, see :ref:`map-reduce`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1672
msgid "Implicit Type Casting Rules in KL"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1674
msgid ""
"When a function or method is called in KL, but the types of the arguments do"
" not exactly match the types of the parameters for any polymorphic version "
"of the function or method, KL will attempt to find the best match using "
"implicit casts.  The best match is chosen as follows:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1676
msgid ""
"The number of arguments must exactly match the number of parameters.  "
"Therefore, if there is a mismatch, the polymorphic version is not "
"considered.  For example, if the function call :code:`foo(14, 23)` is made "
"and there is a function :code:`foo(Integer)` available, it will not be "
"considered because it only takes one parameter but two arguments have been "
"given."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1678
msgid ""
"If the number of parameters matches the number of arguments, the \"cost\" of"
" the call is computed as the maximum \"cost\" for each argument.  The cost "
"for each argument is computed as follows:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1680
msgid "The cost is zero if there is an exact type match"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1681
msgid ""
"The cost is very low for inheritance, ie. if the parameter type is "
":code:`A`, the argument type is :code:`B`, and :code:`B` inherits from "
":code:`A`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1682
msgid ""
"Otherwise, the cost is computed on a per-type basis, and are what would "
"generally be expected.  For instance, casts from smaller integer values to "
"larger ones (eg. :code:`UInt16` to :code:`UInt32`) are very low cost, "
"whereas expensive operations (conversions to strings, numerical conversions "
"that might lose precision) have a high cost."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1685
msgid "Type Aliases"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1687
msgid ""
"The ``alias`` statement can be used to alias a type to make code more "
"readable.  Its syntax is the same as a variable declaration::"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1693
msgid ""
"``alias`` statements must appear within the global scope of a KL program."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1710
msgid "The ``Data`` Type and the ``data`` and ``dataSize`` Methods"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1712
msgid ""
"When interfacing with external libraries such as OpenGL, it is sometimes "
"necessary to get direct access to the data underlying a value.  An example "
"is a library call that takes a pointer to data.  KL itself has no notion of "
"pointers; instead, KL has the concept of the ``Data`` type whose value is a "
"pointer to data which can be passed to an external library call."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1714
msgid ""
"Most values in KL have a built-in method called ``data`` that returns a "
"value of type ``Data``, and a built-in method called ``dataSize`` that "
"returns a value of type ``Size``.  The value returned by the ``data`` method"
" is a pointer to the data underlying the value, and the value returned by "
"the ``dataSize`` method is the number of bytes the value occupies in memory."
"  The only values which do not support the ``data`` and ``dataSize`` methods"
" are dictionaries as well as other derived types that do not lay out their "
"elements or members contiguously in memory:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1724
msgid ""
"Unlike pointers in C and C++, the values returned by ``data`` methods cannot"
" be inspected or used in any expressions; the only thing which can be done "
"is a cast to :code:`Boolean`, which will be :code:`true` if and only if the "
"``Data`` value points to a value whose size is greater than zero.  However, "
"these ``Data`` values can be passed directly to external library functions "
"provided by Fabric itself or Fabric extensions, where they are used as "
"pointers to data in memory."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1726
msgid ""
"For values of type ``String``, the value returned by ``dataSize`` includes a"
" null terminator that is automatically appended to the string by Fabric; "
"this is so that the string data can be directly used in C library calls as a"
" regular C string.  If you want to pass the number of characters in the "
"string, pass ``string.length`` instead."
msgstr ""

#: ..\..\source\KLProgrammingGuide\types.rst:1728
msgid "Example of ``Data`` values and the ``data`` and ``dataSize`` methods:"
msgstr ""
