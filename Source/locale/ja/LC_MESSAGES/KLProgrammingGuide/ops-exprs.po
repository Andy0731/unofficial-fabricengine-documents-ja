#
msgid ""
msgstr ""
"Project-Id-Version: Fabric Engine 2.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-10-06 18:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:4
msgid "Operators and Expressions"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:6
msgid ""
"This chapter explains the possible operators and resulting expressions in "
"KL.  Generally, KL has the same operator and expression syntax as JavaScript"
" and C, and in particular follows exactly the same precedence and "
"associativity rules."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:11
msgid "Operators"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:13
msgid ""
"KL supports the same basic set of operators as JavaScript and C.  These "
"operations are broadly categorized as :ref:`arithmetic operators "
"<arithmetic-ops>`, :ref:`logical operators <logical-ops>`, :ref:`bitwise "
"operators <bitwise-ops>` and :ref:`assignment operators <ass-ops>`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:18
msgid "Arithmetic Operators"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:21
msgid "Add and Subtract"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:23
msgid ""
"When ``+`` or ``-`` appear between two expressions they are referred to as "
"the :dfn:`add` and :dfn:`subtract` binary operators.  These operators are "
"pre-defined for all integer and floating point types, where they perform the"
" usual arithmetic operations, but they can also be overloaded to apply to "
"user-defined structures or different combinations of types.  For example, it"
" is possible to define an operator that takes a user-defined ``Rect`` on the"
" left and a user-defined ``Point`` on the right."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:25
msgid ""
"In addition to being pre-defined for integer and floating-point types, the "
"``+`` (add) operator (but not the ``-`` (subtract) operator) is defined for "
"the ``String`` type; the result of adding two strings is the two strings "
"concatenated together."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:28
msgid "Multiply, Divide and Remainder"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:30
msgid ""
"When ``*``, ``/`` or ``%`` appear between two expressions they are referred "
"to as the :dfn:`multiply`, :dfn:`divide` and :dfn:`remainder` binary "
"operators.  These operators are pre-defined for all integer and floating "
"point types, where they perform the usual arithmetic operations, but they "
"can also be overloaded to apply to user-defined structures or different "
"combinations of types.  For example, it is possible to define a multiply "
"operator that takes a ``Float32`` on the left and a user-defined ``Vec3`` on"
" the right."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:33
msgid "Unary Plus and Minus"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:35
msgid ""
"When ``+`` or ``-`` appears in front of an integer or floating-point "
"expression without an expression to the left they are referred to as the "
":dfn:`unary plus` and :dfn:`unary minus` operators.  The unary plus operator"
" doesn't do anything to the value it operates on, but the unary minus "
"operator returns the value that, when added to the original, produces zero "
"(for unsigned integer expressions); for signed integer and floating-point "
"expressions, this is value of the expression with its sign reversed."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:38
msgid "Increment and Decrement Operators"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:40
msgid ""
"The ``++`` (increment) and ``--`` (decrement) operators can be used to add "
"one to or subtract one from a variable.  These operators have the following "
"properties:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:42
msgid ""
"The operators only work on variables or input-output parameters; then cannot"
" operate on constants or input parameters.  This is because they change the "
"value of the expression."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:44
msgid "They only operate on integer values."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:46
msgid ""
"Each operator can appear either *precede* or *follow* the variable it "
"operates on.  When it precedes the variable, the value of the expression is "
"the value of the variable *after* incrementing; this is referred to as a "
"*prefix* increment (or decrement).  When it follows the variable, the result"
" is the value of the variable *before* incrementing; this is referred to as "
"a *postfix* increment (or decrement)."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:48
msgid "They cannot be overloaded."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:53
msgid "Logical Operators"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:58
msgid "Equality Operators"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:60
msgid ""
"When ``==`` or ``!=`` appear between two expressions they are referred to as"
" the :dfn:`equal-to` or :dfn:`not-equal-to` binary operators, respectively; "
"collectively, they are referred to as the :dfn:`equality operators`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:62
msgid ""
"The equality operators are pre-defined for all integer and floating-point "
"types as well as the ``Boolean`` and ``String`` types.  They can also be "
"overloaded to apply to user-defined structure and specific object types or "
"combinations of different types."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:67
msgid "Identity Operators"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:69
msgid ""
"When ``===`` or ``!==`` appear between two expressions they are referred to "
"as the :dfn:`identical-to` or :dfn:`not-identical-to` binary operators, "
"respectively; collectively, they are referred to as the :dfn:`identity "
"operators`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:71
msgid ""
"The identity operators are pre-defined only for :ref:`object types "
"<KLPG.types.objects>` and :ref:`interface types <KLPG.types.interfaces>`.  "
"They test whether two objects or interfaces refer to the same object, ie. "
"whether changing one will change the other."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:76
msgid "Relational Operators"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:78
msgid ""
"When ``<``, ``<=``, ``>`` or ``>=`` appear between two expressions they are "
"referred to as the :dfn:`less-than`, :dfn:`less-than-or-equal-to`, :dfn"
":`greater-than` or :dfn:`greater-than-or-equal-to` binary operators, "
"respectively; collectively, they are referred to as the :dfn:`relational "
"operators`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:80
msgid ""
"The relational operators are pre-defined for all integer and floating-point "
"types as well as the ``String`` type.  They can also be overloaded to apply "
"to user-defined structure types or combinations of different types."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:83
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:261
msgid "Logical AND"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:85
msgid ""
"When ``&&`` appears between two expressions it is referred to as the "
":dfn:`logical AND` binary operator.  Logical AND operates as follows: the "
"left operand is cast to a ``Boolean`` (ie. a ``Boolean`` value is "
"constructed from the left hand operand).  If the result is ``true``, the "
"result is the right operand, otherwise the result is the left operand."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:87
msgid ""
"The behavior of logical AND is the same as in JavaScript but different than "
"C.  In C, the result value of a logical AND is always an integer (bool in "
"C++)."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:89
msgid ""
"It is not possible to overload the logical AND operator.  However, you can "
"\"enable\" it for custom types (structures) by creating a ``Boolean`` "
"constructor with a single parameter whose type is the type of the left "
"operand."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:92
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:263
msgid "Logical OR"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:94
msgid ""
"When ``||`` appears between two expressions it is referred to as the "
":dfn:`logical OR` binary operator.  Logical OR operates as follows: the left"
" operand is cast to a ``Boolean`` (ie. a ``Boolean`` value is constructed "
"from the left hand operand).  If the result is ``true``, the result is the "
"left operand, otherwise the result is the right operand."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:96
msgid ""
"The behavior of logical OR is the same as in JavaScript but different than "
"C.  In C, the result value of a logical AND is always an integer (bool in "
"C++)."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:98
msgid ""
"It is not possible to overload the logical OR operator.  However, you can "
"\"enable\" it for custom types (structures) by creating a ``Boolean`` "
"constructor with a single parameter whose type is the type of the left "
"operand."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:101
msgid "Logical NOT"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:103
msgid ""
"When ``!`` (exclamation mark) appears in front of an expression it is "
"referred to as the :dfn:`logical NOT` unary operator.  Logical NOT inverts "
"the logical value of expression; more specifically, it constructs a new "
"``Boolean`` value from the expression and then inverts its logical value.  "
"Therefore, logical not can be applied to any expression that has a "
"``Boolean`` constructor that takes a single parameter whose types is the "
"type of the expression."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:105
msgid ""
"It is not possible to overload the logical NOT operator.  However, you can "
"\"enable\" it for custom types (structures) by creating a ``Boolean`` "
"constructor with a single parameter whose type is the structure."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:108
msgid "The Conditional Operator"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:110
msgid ""
"When three expressions are separated by ``?`` (question mark) and ``:`` "
"(colon) it is referred to as the :dfn:`conditional operator` (or "
":dfn:`ternary operator`).  The conditional operator constructs a ``Boolean``"
" from the first operand; if it has value ``true``, the result is the second "
"operand, otherwise it is the third."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:112
msgid "It is not possible to overload the conditional operator."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:115
msgid "The Comma Operator"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:117
msgid ""
"When two expressions are separated by ``,`` (comma) it is referred to as the"
" :dfn:`comma operator`).  The comma operator first evaluates the left-hand "
"expression, throwing away the result, and then evaluates the right-hand "
"expression.  The value of the right-hand expression is the value of the "
"comma operator expression."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:119
msgid "It is not possible to overload the comma operator."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:124
msgid "Bitwise Operators"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:127
msgid "Bitwise AND, OR and XOR"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:129
msgid ""
"When ``&``, ``|`` or ``^`` appear between two expressions they are referred "
"to as :dfn:`bitwise AND`, :dfn:`bitwise OR` or :dfn:`bitwise XOR` binary "
"operators, respectively."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:131
msgid ""
"Bitwise AND, OR and XOR are predefined for all integer types; they perform "
"the usual bitwise operation on the two values.  They are also predefined for"
" the ``Boolean`` type, which is treated as if it was a single bit with value"
" 1 (if true) or 0 (if false)."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:133
msgid ""
"Bitwise AND, OR and XOR can be overloaded for user-defined structures or "
"combinations of different types."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:136
msgid "Bitwise NOT"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:138
msgid ""
"When ``~`` (tilde) appears in front of an expression it is referred to as "
"the :dfn:`bitwise NOT` unary operator."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:140
msgid ""
"Bitwise NOT is predefined for all integer types; it inverts the state of the"
" bits of the value.  It is also predefined for the ``Boolean`` type, which "
"is treated as if it was a single bit with value 1 (if true) or 0 (if false)."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:143
msgid "Left and Right Shift"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:145
msgid ""
"When ``<<`` or ``>>`` appear between two expressions they are referred to as"
" the :dfn:`left shift` or :dfn:`right shift` binary operators, respectively."
"  These operators are pre-defined for all integer types, where they perform "
"a left or right bit shift of the left operand by the number of bits given in"
" the right operand."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:147
msgid ""
"A right-shift of a signed integer value will fill the left most bits with "
"the sign bit, not with zeros.  Right shifts of unsigned integer values and "
"left shifts of any integer values always fill with zeros."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:149
msgid ""
"It is possible to overload the shift operators for user-defined types, and "
"even provide non-integer types as right-hand operands."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:154
msgid "Assignment Operators"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:157
msgid "Direct Assignment Operator"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:159
msgid ""
"When ``=`` appears between two expressions it is referred to as the "
":dfn:`direct assignment operator`.  The direct assignment operator is "
"predefined for all types; see :ref:`KLPG.types` for details on how direct "
"assignment operates for a given type.  It is also possible to overload the "
"direct assignment operator for any type. See :ref:`overloading-direct-ass-"
"op`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:162
msgid "Compound Assignment Operators"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:164
msgid ""
"Any of the arithmetic or bitwise (but not logical) binary operators can be "
"combined with ``=`` to form a :dfn:`compound assignment operator`; these are"
" specifically ``+=``, ``-=``, ``*=``, ``/=``, ``%=``, ``<<=``, ``>>=``, "
"``&=``, ``^=`` and ``|=``."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:166
msgid ""
"A compound assignment operator is predefined for a given type if and only if"
" the corresponding binary operator is predefined for the type.  It is also "
"possible to overload the compound assignment operator for any type, and it "
"is even possible to have different types for the left and right operands. "
"See :ref:`overloading-compound-ass-ops`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:169
msgid "Operators and Polymorphism"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:171
msgid ""
"Operator invocations are subject to the same rules as function calls with "
"respect to polymorphism.  If an exact match for an operator with the "
"parameter types equal to the operand types is not found, KL will find the "
"best-match among the existing implementations of the operator.  This makes "
"it possible, for instance, to add an integer and a string; the result is "
"that the integer is cast to a string and then the strings are concatenated."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:173
msgid ""
"For more information on polymorphism and best-match rules, see "
":ref:`polymorphism`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:176
msgid "Expressions"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:178
msgid ""
"There are two types of expressions in KL: simple expressions and compound "
"expressions."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:183
msgid "Simple Expressions"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:185
msgid ""
":dfn:`Simple expressions` are the expressions from which more complex "
"expressions are derived.  The simple expressions are:"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:187
msgid ""
"Symbols that refer to variables, function arguments or constants.  The type "
"of the expression is the type of the entity referred to.  Examples: ``foo``,"
" ``myParam``, ``mathPI``.  See :ref:`scope` for how symbol names are "
"resolved."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:189
msgid ""
"Boolean, integer, floating-point and string constants.  The type of the "
"expression is the type of the constant.  Examples: ``true``, ``42``, "
"``3.14159``, ``FILE``, ``LINE``.  See :ref:`literal-constants`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:192
msgid "Compound Expressions"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:194
msgid ""
":dfn:`Compound expressions` are built from :ref:`simple expressions <simple-"
"exprs>` and/or other compound expressions using :ref:`operators <ops>`."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:196
msgid ""
"The following table lists all the different compound expressions in KL.  "
"Compound expressions are grouped by :dfn:`type`; all expressions of the same"
" type are of the same precedence and share the same associativity.  Compound"
" expression types are listed from highest to lowest precedence."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:199
msgid "Type"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:199
msgid "Associativity"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:199
msgid "Expression(s)"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:201
msgid "Postfix"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:201
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:225
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:231
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:235
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:239
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:247
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:255
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:257
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:259
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:261
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:263
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:289
msgid "left-to-right"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:201
msgid ":samp:`{functionName}({args})`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:203
msgid ":samp:`{expr}[{expr}]`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:205
msgid ":samp:`{expr}.{member}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:207
msgid ":samp:`{expr}.{method}({args})`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:209
msgid ":samp:`{expr}++`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:211
msgid ":samp:`{expr}--`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:213
msgid "Prefix"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:213
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:265
#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:267
msgid "right-to-left"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:213
msgid ":samp:`+{expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:215
msgid ":samp:`-{expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:217
msgid ":samp:`++{expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:219
msgid ":samp:`--{expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:221
msgid ":samp:`!{expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:223
msgid ":samp:`~{expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:225
msgid "Multiplicative"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:225
msgid ":samp:`{expr} * {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:227
msgid ":samp:`{expr} / {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:229
msgid ":samp:`{expr} % {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:231
msgid "Additive"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:231
msgid ":samp:`{expr} + {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:233
msgid ":samp:`{expr} - {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:235
msgid "Shift"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:235
msgid ":samp:`{expr} << {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:237
msgid ":samp:`{expr} >> {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:239
msgid "Relational"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:239
msgid ":samp:`{expr} < {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:241
msgid ":samp:`{expr} <= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:243
msgid ":samp:`{expr} > {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:245
msgid ":samp:`{expr} >= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:247
msgid "Equality Identity"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:247
msgid ":samp:`{expr} == {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:249
msgid ":samp:`{expr} != {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:251
msgid ":samp:`{expr} === {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:253
msgid ":samp:`{expr} !== {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:255
msgid "Bitwise AND"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:255
msgid ":samp:`{expr} & {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:257
msgid "Bitwise XOR"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:257
msgid ":samp:`{expr} ^ {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:259
msgid "Bitwise OR"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:259
msgid ":samp:`{expr} | {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:261
msgid ":samp:`{expr} && {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:263
msgid ":samp:`{expr} || {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:265
msgid "Conditional"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:265
msgid ":samp:`{expr}? {expr}: {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:267
msgid "Assignment"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:267
msgid ":samp:`{expr} = {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:269
msgid ":samp:`{expr} += {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:271
msgid ":samp:`{expr} -= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:273
msgid ":samp:`{expr} *= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:275
msgid ":samp:`{expr} /= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:277
msgid ":samp:`{expr} %= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:279
msgid ":samp:`{expr} <<= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:281
msgid ":samp:`{expr} >>= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:283
msgid ":samp:`{expr} &= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:285
msgid ":samp:`{expr} ^= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:287
msgid ":samp:`{expr} |= {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:289
msgid "Comma"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:289
msgid ":samp:`{expr} , {expr}`"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:293
msgid "Controlling Order of Operations"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:295
msgid ""
"The order of operations can be explicitly controlled by putting ``(`` and "
"``)`` (parentheses) around expressions."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:310
msgid "Scoping Rules"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:312
msgid ""
"The term :dfn:`scope` in programming languages refers to the parts of a "
"program in which variables, constants and functions are visible; the rules "
"that govern how scopes work are referred to as :dfn:`scoping rules`.  Scopes"
" are also responsible for managing the \"lifecycle\" of variables; in the "
"case of KL, this refers to when destructors are called for structure values."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:318
msgid "Types of Scopes"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:320
msgid ""
"In KL, there are four kinds scopes: the global scope, function scopes, "
"compound statement scopes and temporary scopes.  Scopes :dfn:`nest` inside "
"each other; when a KL program refers to a variable by name, the compiler "
"determines which variable is being referred to by searching from the current"
" innermost scope outwards through the nested scopes to the outermost scope "
"(which is always the global scope).  Like C, KL is a statically-scoped "
"language, meaning that the exact variable that is being referred to is "
"resolved at compile time (and not at run time)."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:326
msgid "The Global Scope"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:328
msgid ""
"The global scope is the top-level scope of a KL program.  The symbols that "
"are visible in the global scope are global constants as well as functions "
"and operators.  The global scope is always the outermost scope at any point "
"in a KL program."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:334
msgid "Function Scope"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:336
msgid ""
"Whenever a function or other function-list entity is defined, a function "
"scope is created that is nested inside the global scope.  The arguments to "
"the function are provided within the function scope.  Within the function "
"scope, a function definition also creates a compound statement scope "
"corresponding to the compound statement that constitutes the body of the "
"function."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:344
msgid "Compound Statement Scope"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:346
msgid ""
"Any time that a ``{`` followed by zero or more statements followed by ``}`` "
"is used to introduce a compound statement, a new :dfn:`compound statement "
"scope` is introduced.  Compound statement scopes are nested inside function "
"scopes (when they correspond to the compound statement that constitutes the "
"body of a function) or inside other compound statement scopes."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:348
msgid ""
"When control reaches the end of a compound statement (by executing the last "
"statement or via the ``return``, ``break`` or ``continue`` statements), any "
"structure values that have corresponding destructors will have those "
"destructors executed."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:350
msgid ""
"Note that declaring a loop index variable inside a loop statement is a "
"special case of a compound statement scope.  In the case that the loop body "
"is a compound statement, the corresponding compound statement scope is "
"nested inside the loop's compound statement scope."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:356
msgid "Temporary Scope"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:358
msgid ""
"Any time that a constructor is directly invoked to create a temporary value "
"(see :ref:`KLPG.constructor.invocation.temporary`), a scope is created to "
"contain the temporary value.  The scope encloses the surrounding expression "
"of the temporary value; this means that when the surrounding expression is "
"finished execution, the temporary value's destructor, if it exists, is "
"executed."
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:361
msgid "Nested Scopes Example"
msgstr ""

#: ..\..\source\KLProgrammingGuide\ops-exprs.rst:363
msgid ""
"For a precise understanding of the nesting of KL scopes, study the following"
" example carefully."
msgstr ""
