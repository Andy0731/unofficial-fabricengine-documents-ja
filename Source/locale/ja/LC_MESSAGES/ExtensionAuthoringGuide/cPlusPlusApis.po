#
msgid ""
msgstr ""
"Project-Id-Version: Fabric Engine 2.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-10-06 18:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:4
msgid "Wrapping C++ APIs for use in KL"
msgstr "C++ APIをラップしKLで使用"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:6
msgid ""
"This guide is intended to help developers wrapping C++ extensions for use in"
" KL to use the best practices and follow common conventions when wrapping "
"their own APIs using the EDK."
msgstr ""
"このガイドでは、EDKを用いた C++エクステンションのAPIのラッピング ―KLで使用するため "
"を行う際、使用すべきベストプラクティスと、従うべき一般的な規則を紹介します。"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:9
msgid "Overview"
msgstr "概要"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:11
msgid ""
"The KL language is designed to provide a low barrier to entry for developers"
" migrating from other languages. KL features high level systems such as "
"reference counted containers and interfaces."
msgstr ""
"KL言語は、他の言語から容易に移行してこれるようデザインされています。KLはハイレベルなシステム、例えば参照カウントされるコンテナ、インタフェースを備えてい"
"ます。"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:13
msgid ""
"The goal of wrapping an API for KL is to enable developers working with the "
"KL language to utilise the API in a similar way to how they would work with "
"the API in C++ or other languages where the API is exposed. The consistent "
"mapping of an API ensures that users familiar with the API can transition to"
" KL and quickly become productive without needing to learn new concepts."
msgstr ""
"あるAPIを KLにラッピングする目標は、開発者が KL言語で作業 ―― そのAPIが公開されている C++ あるいは他の言語でのやり方と同じようにその "
"APIを利用し作業できるようにすることです。一貫性のあるAPIのマッピングのおかげで、そのAPIに堪能なユーザが、新しい概念の習得の必要なくKLへ移行し素早"
"く力を発揮することができるようなるのです。"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:16
msgid "C++ API Code:"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:25
msgid "C++ Example Code:"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:33
msgid "KL Example Code:"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:42
msgid ""
"If an API has been well wrapped, then code written in C++ can be migrated to"
" KL with only minor modifications. Classes defined in C++ can be exposed in "
"KL with the same interfaces, meaning that users can create KL type and "
"invoke methods on them as they would in C++. The differences between the KL "
"and the C++ API should mainly be derived from the simpler memory management "
"exposed in KL. Concepts such as pointers and memory allocation are not "
"exposed in KL."
msgstr ""
"よい具合にラップされたAPIであれば、C++のコードをほんの少しの変更でKLへ移植できます。C++に定義したクラスは、KLにも同じインタフェースをもち公開さ"
"れます。つまり、C++と同じようにそのクラスに対し KLの型を作成したりメソッドを呼び出したりすることが可能です。一方 KLと C++ "
"API間での違いは、おもに KLに公開されるより単純なメモリマネジメントに起因します。KLにはポインターやメモリアロケーションといったコンセプトがありません"
"。"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:44
msgid ""
"Where there is direct overlap with the provided KL types, It is preferable "
"to convert the API types directly to the KL types in the API wrapping layer."
" An example of this is basic math types such as Integers, Scalars, Vectors "
"and Quaternions. Fabric Engine comes with a complete math library, so to "
"provide a seamless integration the KL Math types should be generated by the "
"API unless some good reason exists to propagate custom Math types in to KL."
msgstr ""
"KLの型と直接重なる（マップ）するのであれば、APIの型を直接 KLの型へと「APIラッピングレイヤで」直接変換するとより良いです。例えば、基本math型 "
"― 整数、浮動小数点数、ベクタ、クォータニオンといった型です。Fabric Engine には "
"mathライブラリ一式そろっているので、シームレスな統合を目指すのであれば、KLのmath型は カスタム "
"math型をKLへと持っていくような余程の理由がない限り、APIにより生成するべきです。"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:47
msgid "Type Conversion"
msgstr "型の変換"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:49
msgid ""
"Providing a set of utility functions to convert between common data types is"
" the first step in mapping an API from C++ into KL. Conversion functions "
"should be implemented for both directions enabling values to be pushed into "
"the C++ API from KL, and pulled out of the API layer into KL."
msgstr ""
"あるAPIをC++ からKLへとマッピングする第一歩として、共通（common）なデータ型間での変換を行うユーティリティ関数一式用意します。これら関数は双方"
"向の変換を実装し、値をKLからC++ APIへ push, また逆に値をAPIレイヤからKLへとpull することができるようにしましょう。"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:51
msgid ""
"For convenience, you can use the :code:`use namespace` functionality of C++ "
"to avoid prefixing the types and functions:"
msgstr "利便性のためC++の  :code:`use namespace` 機能を利用し、型,関数のプリフィクシングを避けてもよいでしょう。"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:53
msgid "Example Code from the Bullet Integration"
msgstr "Bullet統合からの参考コード"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:72
msgid ""
"These utility methods become a key component of the API wrapping, and should"
" be as simple and performant as possible. These methods are usually used to "
"map arguments provided to methods from KL to the C++ API types and therefore"
" may be called many times per graph evaluation."
msgstr ""
"これらのユーティリティ関数は APIラッピングのキーコンポーネントとなります。可能な限り単純に, しかも効率的にすべきです。なぜなら、メソッドの引数を "
"<KLから C++ API型へ>マップするためこのユーティリティ関数を使用するため、一度のグラフ評価のたびに大量に呼ばれる可能性があるためです。"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:76
msgid ""
"In some circumstances where the KL type's memory layout can be guaranteed to"
" match the memory layout of the C++ API types, the KL type can simply be "
"cast to the C++ type. Using the ref:`EAG.kl2edk` utility, you can validate "
"the exact memory layout of your KL types by checking the generated header "
"files. See :ref:`EAG.kl2edk`"
msgstr ""
"KL型のメモリレイアウトと、C++ APIの型のメモリレイアウトが一致すると保証されている状況では、KL型はC++型へと単純にキャストすることができます。 "
":ref:`EAG.kl2edk` ユーティリティを使い、生成されたヘッダファイルをチェックし、KL型のメモリレイアウトが完全に一致するか検証できます。 "
":ref:`EAG.kl2edk` 参照"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:81
msgid "Mapping Classes to Objects"
msgstr "Class から Object へのマッピング"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:83
msgid ""
"An API might define a collection of C++ classes organized into a hierarchy. "
"The user of the API can construct these classes and invoke methods on them. "
"Conceptually, the classes defined in the API should map to KL Objects. An "
"instance of a KL Object should represent an instance of the C++ class. This "
"relationship is managed via mapping methods on KL objects to static methods "
"in the C++ wrapper layer."
msgstr ""
"ある APIは < 1個の階層にまとめあげた、C++クラスのコレクション>として定義することができます。API利用者は、それらクラスをコンストラクトし、その"
"メソッドを呼び出すことができます。理想的には、API中定義された 全class は KLの object "
"にマップすべきです。KLオブジェクトのインスタンスは、C++クラスのインスタンスを表すべきです。この2つの間の関係は、<KL "
"objectのマッピングメソッド> を通じ <C++ラッパレイヤの staticメソッド> へと管理されます。"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:87
msgid "Memory Management"
msgstr "メモリ管理"

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:89
msgid ""
"In KL, Objects are ref counted objects. Only once all references to an "
"object are removed will an object be destroyed. KL objects provide "
"constructors and destructors that are called when the object is created or "
"destroyed. The lifetime of the KL object should be used to manage the "
"lifetime of the instantiated C++ classes that the object represents."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:103
msgid "Mapping Public methods"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:105
msgid ""
"Mapping methods from KL to C++ starts by defining the KL method, and the "
"name of a static method that would be invoked when that method is called "
"from C++. Only the public methods that define the interface of a class need "
"to be mapped from KL to C++. These methods are the methods that clients of "
"the class must invoke when working with the class. The KL objects represent "
"a mapping of the public interface of the class, rather than a complete "
"mapping of all protected and private methods."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:117
msgid "Public Members"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:123
msgid "Pure data container structs"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:125
msgid ""
"In some cases, a C++ API may define simple structs that are used to pass a "
"large number of variables into a constructor or method. In this case an "
"equivalent KL struct can be defined, complete with all the same members. "
"When the KL struct is passed into a method, the C++ mapping of the method "
"can handle a manual conversion of the KL struct to the C++ struct. In the "
"same way the Math types are mapped, each of the members is simply converted "
"to the C++ API types."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:155
msgid "Passing Arrays from KL to a C-Style API"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:157
msgid ""
"Some C++ API's, typically APIs developed for use in game runtimes, avoid "
"using C++ array representations(e.g. std::vector), or any other higher level"
" array representations, and instead use a combination of pointers and count "
"values. Because pointers are not exposed in KL, the exposed KL API must "
"operate at a slightly higher level, rather than expose the C++ method "
"arguments directly in KL. A single array value can be passed into the method"
" and in the C++ wrapping code, the arguments expanded for the C-style API. "
"This provides a slightly higher level, but easier to use API in KL than the "
"C++ API. It is up to the developers discretion to adopt the higher level "
"function signatures when required and provide the mapping of the arguments "
"in the C++ wrapping code. Kl2edk cannot automatically expand the KL "
"arguments required for these functions, so usually these methods must be "
"manually implemented."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:181
msgid ""
"If the C++ class merely uses the passed in array values to extract some "
"data, then as soon as the call stack unwinds the array may be safely "
"destroyed. If the C++ API class stores the pointer to this array, then the "
"memory associated with this array must be referenced by the KL object to "
"ensure that it is not freed before the class is destroyed. The reference in "
"KL to the array will ensure that the array is not freed by KL before the KL "
"class is destroyed. Whenever a C++ class has a dependency on the existence "
"of memory allocated elsewhere, a KL reference to the data must be set. See "
"'Managing Data Ownership and bidirectional relationships' below."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:192
msgid ""
"The provided Bullet extension implements this slightly higher level wrapping"
" of the Bullet API, enabling KL arrays to be passed into methods that, in "
"the C++ API expect a count and pointer to be passed. Look at the provided "
"source code of the Bullet extension for examples of how this has been "
"implemented."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:195
msgid "Mapping Class Hierarchies"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:197
msgid ""
"Often C++ APIs are structured as hierarchies of classes that inherit from "
"each other. Objects in KL cannot currently inherit from base objects, and so"
" a direct mapping of a C++ class hierarchy is not possible."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:199
msgid ""
"KL provides a system of interfaces which enable the specification of a set "
"of methods that a given class must implement. Interfaces are similar to "
"pure-virtual classes in C++, and therefore provide no implementations of "
"methods or member values. Objects can support multiple interfaces, enabling "
"class hierarchies to be supported through the implementation of interfaces, "
"one for each of the inherited classes in the class hierarchy."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:201
msgid ""
"Each KL object must then support the interfaces defined for each of the "
"classes it inherits from in the class hierarchy."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:204
msgid "C++ API Code"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:219
msgid "KL Wrapping Code"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:241
msgid "C++ Wrapping Code."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:258
msgid "KL Example Code"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:274
msgid ""
"For deep class hierarchies, many interfaces may be required, and all public "
"methods exposed through the inheritance chain must be implemented directly "
"by the leaf objects."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:277
msgid ""
"Full support for Inheritance ok KL objects scheduled for an upcoming release"
" which greatly simplify the mapping of C++ hierarchies."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:281
msgid "Managing Data Ownership and bidirectional relationships"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:283
msgid ""
"In some APIs, you may have a collection of classes whose lifetimes are "
"related, and must be destroyed in a specific order. KL can be utilized to "
"manage the lifetimes of the objects in the system, such that objects will "
"always be destroyed in a predictable order."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:285
msgid ""
"The Ref<> feature in KL is a raw unmanaged pointer. Ref<> pointers will not "
"affect the lifetime of an object, and so can be used in cases where "
"backpointers are required."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:330
msgid "Handling Dependencies between Classes"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:332
msgid ""
"When a class hierarchy is being mapped to KL, the dependencies between the "
"class declarations needs to be mapped to kl. The Place where these "
"dependencies are mapped, is the fpm.json file that loads the kl files for "
"the extension."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:335
msgid "C++ Code Class A"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:343
msgid "C++ Code  Class B"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:352
msgid "KL Code object A"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:385
msgid ""
"The dependencies between the C++ classes needs to be reflected in the "
"definition of the KL objects, and in the order that the classes are loaded "
"by the fpm.json file."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:387
msgid ""
"Note: Object B maintains a KL reference to Object A, to ensure that its "
"lifetime lasts longer than B. Only once A is destroyed or releases its "
"reference to B(as long as only A reference B), B will be destroyed."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:392
msgid "Other Tips and Tricks"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:395
msgid "Mapping Const Functions to KL as const functions"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:399
#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:418
msgid "C++ Code"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:408
#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:427
#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:442
msgid "KL Code"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:438
msgid "Cloning Objects in KL"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:440
msgid ""
"When a KL object that references some C++ data is cloned in KL, then the "
"expected behavior is that the C++ class is also closed, ensuring that the "
"1-1 mapping of objects to C++ classes."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:453
msgid "C++ code"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:100
msgid ""
"KL objects must be referenced by at least once by an owning class or node to"
" ensure that they are not destroyed. By maintaining references to objects, "
"you can guarantee that they will not be destroyed, and can control when they"
" will eventually be freed. For systems of interdependent classes see "
"?eManaging Data ownership and bidirectional relationships?f below."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:119
msgid ""
"Mapping of public members from KL to C++ is not automatic. There is no "
"facility in KL to detect when a KL Object?fs or Struct?fs member value "
"changes to automatically synchronize values to the mapped C++ class or "
"struct. Ideally all interactions with a struct or class occur through public"
" methods(except in the ?eSimple Data-Container Structs?f example provided "
"below)."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:287
msgid ""
"Note: If 2 classes reference each other, then neither class will ever be "
"destroyed due to the cyclic reference. A Owner object should reference its "
"?eowned?f objects, and those ?eowned?f objects should maintain simple "
"?eRef?f pointers back to the owners. Ref pointers must be manually "
"maintained. If the pointer is not nulled and the owner is destroyed, the "
"pointer will become garbage and cause a crash if accessed. Cleanup is "
"required to ensure your code is stable under all conditions. ."
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:360
msgid "KL Code object B"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:369
msgid "Resulting MyExt.fpm.json file"
msgstr ""

#: ..\..\source\ExtensionAuthoringGuide\cPlusPlusApis.rst:396
msgid ""
"By default, kl methods that return values are const. You may have a class "
"that declares methods that take non-const reference arguments and perform "
"computation returning the results in the args. To declare a KL function that"
" is also cost, simply append a ?e??f as the end of the function name."
msgstr ""

#~ msgid ""
#~ "KL objects must be referenced by at least once by an owning class or node to"
#~ " ensure that they are not destroyed. By maintaining references to objects, "
#~ "you can guarantee that they will not be destroyed, and can control when they"
#~ " will eventually be freed. For systems of interdependent classes see "
#~ "‘Managing Data ownership and bidirectional relationships’ below."
#~ msgstr ""

#~ msgid ""
#~ "Mapping of public members from KL to C++ is not automatic. There is no "
#~ "facility in KL to detect when a KL Object’s or Struct’s member value changes"
#~ " to automatically synchronize values to the mapped C++ class or struct. "
#~ "Ideally all interactions with a struct or class occur through public "
#~ "methods(except in the ‘Simple Data-Container Structs’ example provided "
#~ "below)."
#~ msgstr ""

#~ msgid ""
#~ "Note: If 2 classes reference each other, then neither class will ever be "
#~ "destroyed due to the cyclic reference. A Owner object should reference its "
#~ "‘owned’ objects, and those ‘owned’ objects should maintain simple ‘Ref’ "
#~ "pointers back to the owners. Ref pointers must be manually maintained. If "
#~ "the pointer is not nulled and the owner is destroyed, the pointer will "
#~ "become garbage and cause a crash if accessed. Cleanup is required to ensure "
#~ "your code is stable under all conditions. ."
#~ msgstr ""

#~ msgid ""
#~ "By default, kl methods that return values are const. You may have a class "
#~ "that declares methods that take non-const reference arguments and perform "
#~ "computation returning the results in the args. To declare a KL function that"
#~ " is also cost, simply append a ‘?’ as the end of the function name."
#~ msgstr ""
